- name: A41 | List Users in Windows Administrator Group (Nested AD Group Expansion)
  ansible.windows.win_powershell:
    script: |
      try {
        # --- Helper Function: Parse 'net group' output ---
        function Parse-NetOutput {
          param([string[]]$Lines)
          $members = @()
          $inSection = $false
          foreach ($line in $Lines) {
            if ($line -match "^-+$") { $inSection = $true; continue }
            if ($inSection) {
              if ($line -match "The command completed successfully") { break }
              $t = $line.Trim()
              if (-not [string]::IsNullOrWhiteSpace($t)) { 
                # Split multiple users on one line (standard net command behavior)
                $parts = $t -split '\s+'
                $members += $parts
              }
            }
          }
          return ,$members
        }

        # --- Step 1: Get Local Administrator Group Members (Safe Method) ---
        $adminGroupSid = "S-1-5-32-544"
        $localAdminGroup = Get-LocalGroup | Where-Object { $_.SID -eq $adminGroupSid }
        $localMembers = @()

        if ($localAdminGroup) {
          try {
             $localMembers = Get-LocalGroupMember -Group $localAdminGroup.Name -ErrorAction Stop
          } catch {
             # Fallback to ADSI if standard cmdlet fails (Handle Orphaned SIDs)
             try {
                $adsiGroup = [ADSI]"WinNT://$env:COMPUTERNAME/$($localAdminGroup.Name),group"
                $membersRaw = @($adsiGroup.psbase.Invoke("Members"))
                $localMembers = $membersRaw | ForEach-Object {
                    $path = $_.GetType().InvokeMember("ADsPath", 'GetProperty', $null, $_, $null)
                    $name = $_.GetType().InvokeMember("Name", 'GetProperty', $null, $_, $null)
                    $class = $_.GetType().InvokeMember("Class", 'GetProperty', $null, $_, $null)
                    
                    # Convert ADSI object to custom object compatible with logic below
                    [PSCustomObject]@{
                        Name = if ($path -match "WinNT://(?<Domain>[^/]+)/") { "$($matches['Domain'])\$name" } else { $name }
                        ObjectClass = $class
                        PrincipalSource = if ($path -match "WinNT://$env:COMPUTERNAME") { "Local" } else { "ActiveDirectory" }
                    }
                }
             } catch {
                # Critical failure fetching local members
                $localMembers = @()
             }
          }
        }

        # --- Step 2: Filter for Domain Groups and Expand Them ---
        $expandedGroups = @{}
        $rawOutput = New-Object System.Collections.ArrayList
        
        foreach ($member in $localMembers) {
            # Check if member is likely a Domain Group (Contains '\' and not local machine name, or PrincipalSource is AD)
            $isDomain = ($member.PrincipalSource -eq 'ActiveDirectory') -or ($member.Name -like "*\*" -and $member.Name -notlike "$env:COMPUTERNAME\*")
            
            # We treat it as a group to expand if ObjectClass says Group, or if we are unsure (best effort)
            $shouldExpand = $isDomain -and ($member.ObjectClass -eq 'Group' -or $member.ObjectClass -eq $null)

            if ($shouldExpand) {
                # Extract pure group name (remove DOMAIN\)
                $cleanGroupName = $member.Name -split '\\' | Select-Object -Last 1
                
                [void]$rawOutput.Add("checking group: $cleanGroupName")

                # Query Domain
                $cmd = "net group `"$cleanGroupName`" /domain"
                $out = & cmd.exe /c $cmd 2>&1
                
                $joined = ($out -join "`n")
                if ($joined -match "The command completed successfully") {
                   $users = Parse-NetOutput -Lines $out
                   $expandedGroups[$member.Name] = $users
                } else {
                   $expandedGroups[$member.Name] = @("Could not retrieve members (Group might not exist in this Domain context)")
                }
            }
        }

        # --- Step 3: Build Final Result ---
        $result = @{
          LocalAdminGroupName = $localAdminGroup.Name
          LocalMembers = $localMembers | Select-Object Name, ObjectClass, PrincipalSource
          ExpandedDomainGroups = $expandedGroups
          TotalLocalMembers = $localMembers.Count
        }

        $result | ConvertTo-Json -Depth 4 -Compress
      } catch {
        @{
          Error = $_.Exception.Message
        } | ConvertTo-Json -Compress
      }
  register: a41_result
  changed_when: false
  failed_when: false
  vars:
    ansible_become: true
    ansible_become_method: runas
    ansible_become_user: "{{ CLP_user_domain }}\\{{ cyberark_pass.result.UserName }}"
    ansible_become_password: "{{ cyberark_pass.result.Content }}"

- name: A41 | normalize result
  set_fact:
    a41_raw: "{{ (a41_result.output | default([])) | join('') | trim }}"

- name: A41 | parse result
  set_fact:
    a41_data: >-
      {%- if a41_raw is string and a41_raw != '' -%}
        {{ a41_raw | from_json }}
      {%- elif a41_raw is mapping -%}
        {{ a41_raw }}
      {%- else -%}
        {}
      {%- endif -%}

- name: A41 | build output text
  set_fact:
    a41_actual_text: |-
      {% if a41_data.Error is defined %}
      Error: {{ a41_data.Error }}
      {% else %}
      Total Local Administrators: {{ a41_data.TotalLocalMembers | default(0) }}
      
      --- Details ---
      {% for member in a41_data.LocalMembers %}
      [Member] {{ member.Name }} ({{ member.ObjectClass }})
      {% if member.Name in a41_data.ExpandedDomainGroups %}
        -> Domain Group Members:
        {% for user in a41_data.ExpandedDomainGroups[member.Name] %}
          - {{ user }}
        {% endfor %}
      {% endif %}
      <br>
      {% endfor %}
      {% endif %}

- name: A41 | determine status
  set_fact:
    a41_status: >-
      {%- if a41_data.Error is defined -%}
      Fail
      {%- else -%}
      OK
      {%- endif -%}

# Ensure host structure exists
- name: A41 | ensure host struct
  set_fact:
    win_os_checks_struct: >-
      {{
        (win_os_checks_struct | default({})) |
        combine({
          inventory_hostname: (
            (win_os_checks_struct[inventory_hostname] | default({})) |
            combine({
              'name': inventory_hostname,
              'note': (win_os_checks_struct[inventory_hostname].note | default('')),
              'checks': (win_os_checks_struct[inventory_hostname].checks | default([]))
            }, recursive=True)
          )
        }, recursive=True)
      }}

# Append to report
- name: A41 | append row
  set_fact:
    win_os_checks_struct: >-
      {{
        win_os_checks_struct |
        combine({
          inventory_hostname: (
            win_os_checks_struct[inventory_hostname] |
            combine({
              'checks': (win_os_checks_struct[inventory_hostname].checks + [{
                'control': 'A41',
                'method': 'PowerShell: Get-LocalGroupMember + net group /domain',
                'checking_item': 'Users in Windows Administrator Group',
                'expected': 'Display AD groups within Local Admin group with their respective memberships.',
                'actual': a41_actual_text,
                'status': a41_status
              }])
            }, recursive=True)
          )
        }, recursive=True)
      }}
